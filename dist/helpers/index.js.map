{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/helpers/index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as FileUtils from '@jfonx/file-utils';\nimport * as findNodeModulesPath from 'find-node-modules';\nimport * as fs from 'fs';\nimport { sync } from 'globby';\nimport { dirname, join } from 'path';\n\nexport interface IRawTSConfig {\n  extends?: string;\n  compilerOptions?: {\n    baseUrl?: string;\n    outDir?: string;\n    paths?: { [key: string]: string[] };\n  };\n}\n\nexport interface ITSConfig {\n  baseUrl?: string;\n  outDir?: string;\n  paths?: { [key: string]: string[] };\n}\n\nexport const mapPaths = (\n  paths: { [key: string]: string[] },\n  mapper: (x: string) => string\n): { [key: string]: string[] } => {\n  const dest = {} as { [key: string]: string[] };\n  Object.keys(paths).forEach((key) => {\n    dest[key] = paths[key].map(mapper);\n  });\n  return dest;\n};\n\nexport const loadConfig = (file: string): ITSConfig => {\n  const {\n    extends: ext,\n    compilerOptions: { baseUrl, outDir, paths } = {\n      baseUrl: undefined,\n      outDir: undefined,\n      paths: undefined\n    }\n  } = FileUtils.toObject(file) as IRawTSConfig;\n\n  const config: ITSConfig = {};\n  if (baseUrl) {\n    config.baseUrl = baseUrl;\n  }\n  if (outDir) {\n    config.outDir = outDir;\n  }\n  if (paths) {\n    config.paths = paths;\n  }\n\n  if (ext) {\n    let parentConfig: ITSConfig;\n    if (ext.startsWith('.')) {\n      parentConfig = loadConfig(join(dirname(file), ext));\n    } else {\n      parentConfig = loadConfig(resolveTsConfigExtendsPath(ext, file));\n    }\n    return {\n      ...parentConfig,\n      ...config\n    };\n  }\n\n  return config;\n};\n\nexport function resolveTsConfigExtendsPath(ext: string, file: string): string {\n  const tsConfigDir = dirname(file);\n  const node_modules = findNodeModulesPath({ cwd: tsConfigDir })[0];\n  const targetPath = join(tsConfigDir, node_modules, ext);\n  if (ext.endsWith('.json')) {\n    return targetPath;\n  }\n  let isDirectory = false;\n  try {\n    isDirectory = fs.lstatSync(targetPath).isDirectory();\n  } catch (err) {}\n  return isDirectory ? join(targetPath, 'tsconfig.json') : `${targetPath}.json`;\n}\n\nexport function getProjectDirPathInOutDir(\n  outDir: string,\n  projectDir: string\n): string | undefined {\n  const dirs = sync(\n    [\n      `${outDir}/**/${projectDir}`,\n      `!${outDir}/**/${projectDir}/**/${projectDir}`,\n      `!${outDir}/**/node_modules`\n    ],\n    {\n      dot: true,\n      onlyDirectories: true\n    }\n  );\n\n  /* Rechercher le chemin le plus long */\n  dirs.sort((dirA, dirB) => {\n    return dirB.split('/').length - dirA.split('/').length;\n  });\n  return dirs[0];\n}\n\nexport function existsResolvedAlias(path: string): boolean {\n  if (fs.existsSync(path)) return true;\n\n  const globPattern = [`${path}.{js,jsx}`];\n  const files = sync(globPattern, {\n    dot: true,\n    onlyFiles: true\n  });\n\n  if (files.length) return true;\n  return false;\n}\n\nexport function getAbsoluteAliasPath(\n  basePath: string,\n  aliasPath: string\n): string {\n  const aliasPathParts = aliasPath\n    .split('/')\n    .filter((part) => !part.match(/^\\.$|^\\s*$/));\n\n  let aliasPathPart = aliasPathParts.shift() || '';\n\n  let pathExists: boolean;\n  while (\n    !(pathExists = fs.existsSync(join(basePath, aliasPathPart))) &&\n    aliasPathParts.length\n  ) {\n    aliasPathPart = aliasPathParts.shift();\n  }\n\n  return join(\n    basePath,\n    pathExists ? aliasPathPart : '',\n    aliasPathParts.join('/')\n  );\n}\n"]}